/*=========================================================================
 *
 *  Copyright 2011-2013 The University of North Carolina at Chapel Hill
 *  All rights reserved.
 *
 *  Licensed under the MADAI Software License. You may obtain a copy of
 *  this license at
 *
 *         https://madai-public.cs.unc.edu/software/license/
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/

#include <iostream> // std::cerr
#include <algorithm> // std::transform
#include <fstream> // std::ifstream, std::ofstream
#include <string> // std::string
#include <vector> // std::vector
#include <sstream> // std::ostringstream

#include "GaussianDistribution.h"
#include "LatinHypercubeGenerator.h"
#include "Parameter.h"
#include "UniformDistribution.h"
#include "Paths.h"

#include "madaisys/SystemTools.hxx"


static const char usage[] =
  "usage:\n"
  "  generateTrainingPoints [options] <parameters file> <output directory> <number of points>\n"
  "\n"
  "<parameters file> is a file containing a list of parameters and their ranges\n"
  "\n"
  "  The file should be a text file with a separate line for each parameter\n"
  "  listing the name of the parameter, the type of prior distribution for the\n"
  "  parameter, and a list of parameters defining the prior distribution, e.g.\n"
  "\n"
  "  temperature uniform 245.2 288.0\n"
  "  pressure gaussian 4.7 2.1\n"
  "  ...\n"
  "\n"
  "  Two types of prior distributions are available, uniform and Gaussian.\n"
  "  - Uniform distributions take two numeric arguments, a minimum and maximum\n"
  "    value that define a range outside of which the likelihood is 0.\n"
  "\n"
  "    <parameter name> uniform <range min> <range max>\n"
  "\n"
  "  - Gaussian distributions take two numeric arguments, a mean and a\n"
  "    standard deviation.\n"
  "\n"
  "    <parameter name> gaussian <mean> <standard deviation>\n"
  "\n"
  "\n"
  "<output directory> is a path to the name of the directory that will be created\n"
  "   and which will contain the parameter files holding parameter values\n"
  "   generated by a latin hypercube sampling.\n"
  "\n"
  "\n"
  "<number of points> is the number of points to generate for training.\n"
  "\n"
  "\n"
  "Options:\n"
  "\n"
  "  -h,--help                          Display help message.\n"
  "\n"
  "  -v,--verbose                       Print extra information.\n"
  "\n"
  "  -f,--format {directories,emulator} Select the output format."
  "\n"
  "  -p,--percentile                    Partition space by parameter prior\n"
  "                                     distribution percentile.\n"
  "\n"
  "  -s,--stddev <value>                Number of standard deviations from\n"
  "                                     mean of a parameter's Gaussian\n"
  "                                     distributed prior to include in the\n"
  "                                     sampling.\n"
  "\n";

typedef enum {
  DIRECTORIES_FORMAT, // Pratt format
  EMULATOR_FORMAT     // GaussianProcessEmulator format
} FormatType;


struct CommandLineOptions {
  bool verbose;
  const char * parametersFile;  // First non-flag argument.
  const char * outputDirectory; // Second non-flag argument.
  FormatType formatType;        // Type of the output
  bool partitionSpaceByPercentile;
  double standardDeviations;
  int numberOfTrainingPoints;
};


std::string LowerCase( char * buffer )
{
  std::string outBuffer( buffer );

  std::transform( outBuffer.begin(), outBuffer.end(),
                  outBuffer.begin(), ::tolower );

  return outBuffer;
}

void LowerCase( std::string & s )
{
  std::transform( s.begin(), s.end(),
                  s.begin(), ::tolower );
}


bool ParseCommandLineOptions( int argc, char* argv[], struct CommandLineOptions & options)
{
  // Default values for command-line options
  options.verbose = false;
  options.parametersFile = NULL;
  options.outputDirectory = NULL;
  options.formatType = DIRECTORIES_FORMAT;
  options.partitionSpaceByPercentile = false;
  options.standardDeviations = 3.0;
  options.numberOfTrainingPoints = 100;

  // Parse options
  int argIndex;
  for ( argIndex = 1; argIndex < argc; ++argIndex ) {
    std::string argString( argv[ argIndex ] );

    if ( argString == "-v" || argString == "--verbose" ) {
      options.verbose = true;
    } else if ( argString == "-h" || argString == "--help" ) {
      std::cerr << usage;
      return false;
    } else if ( argString == "-f" || argString == "--format" ) {
      if ( argIndex + 1 < argc ) {
        std::string argString2 = LowerCase( argv[ argIndex + 1 ] );
        if ( argString2 == "directories" ) {
          options.formatType = DIRECTORIES_FORMAT;
        } else if ( argString2 == "emulator" ) {
          options.formatType = EMULATOR_FORMAT;
        } else {
          std::cerr << "Unknown format type '" << argString2 << "' provided to '"
                    << argString << "'. Expected 'directories' or 'emulator'.\n";
          return false;
        }
        argIndex++;
      } else {
        std::cerr << "No format type provided to argument '" << argString
                  << "'. Expected 'directories' or 'emulator'.\n";
        return false;
      }
    } else if ( argString == "-p" || argString == "--percentile" ) {
      options.partitionSpaceByPercentile = true;
    } else if ( argString == "-s" || argString == "--stddev" ) {
      if ( argIndex + 1 < argc ) {
        argIndex++;
        std::string argString2( argv[ argIndex ] );
        options.standardDeviations = atof( argString2.c_str() );
        if ( options.standardDeviations == 0.0 ) {
          std::cerr << "Standard deviations set to 0.0 is not valid. "
                    << "Did you supply a number to '" << argString
                    << "'?\n";
          return false;
        }
      } else {
        std::cerr << "Missing value for '" << argString << "'.\n";
        return false;
      }
    } else {
      break; // No switch
    }
  }

  if ( argIndex < argc ) {
    options.parametersFile = argv[ argIndex++ ];
  } else {
    std::cerr << usage;
    return false;
  }

  if ( argIndex < argc ) {
    options.outputDirectory = argv[ argIndex++ ];
  } else {
    std::cerr << usage;
    return false;
  }

  if ( argIndex < argc ) {
    options.numberOfTrainingPoints = atoi( argv[ argIndex++ ] );
    if ( options.numberOfTrainingPoints <= 0 ) {
      std::cerr << "Number of training points must be greater than 0.\n";
      return false;
    }
  } else {
    std::cerr << usage;
    return false;
  }

  if ( argIndex < argc ) {
    std::cerr << "Extra arguments after '" << options.outputDirectory << "'\n";
    return false;
  }

  // Everything went well
  return true;
}

static void discard_comments( std::istream & i, char comment_character ) {
  int c;
  while (i.good() && ((c = i.peek()) != EOF)) {
    if ((c == ' ') || (c == '\t') || ( c == '\n' )) {
      char ch;
      i.get(ch); // discard whitespace at beginning of line;
    } else if (c == comment_character) {
      std::string s;
      std::getline( i, s );
    } else {
      return; // line begins with some non-comment, non-whitespace character.
    }
  }
}

bool ReadParameters( const struct CommandLineOptions & options,
                     std::vector< madai::Parameter > & parameters )
{
  parameters.clear();

  std::ifstream parameterFile(options.parametersFile);
  if (! parameterFile.good()) {
    std::cerr << "[ReadParameters] Unable to open file " << options.parametersFile << ".";
    return false;
  }

  if ( options.verbose ) {
    std::cout << "Opened file '" << options.parametersFile << "'\n";
  }

  // Parse each parameter as it is listed on a line
  std::string parameterName;
  std::string distributionType;
  discard_comments(parameterFile, '#');
  while (parameterFile >> distributionType >> parameterName) {
    if (! parameterFile.good()) {
      parameterFile.close();
      break;
    }
    LowerCase(distributionType);
    if ( options.verbose ) {
      std::cout << "Read parameter '" << parameterName << "' "
                << "which is of type '" << distributionType << "' ";
    }

    madai::Distribution *distribution = NULL;
    madai::UniformDistribution uniform;
    madai::GaussianDistribution gaussian;

    if ( distributionType == "uniform" ) {
      // Parse minimum and maximum values
      double minimum, maximum;
      parameterFile >> minimum >> maximum;
      if (! parameterFile.good()) {
        std::cerr << "Could not read uniform distribution minimum and maximum\n";
        parameterFile.close();
        return false;
      }
      if ( options.verbose ) {
        std::cout << "with range [" << minimum << ", " << maximum << "]\n";
      }
      uniform.SetMinimum( minimum );
      uniform.SetMaximum( maximum );
      distribution = &uniform;

    } else if ( distributionType == "gaussian" ) {
      // Parse mean and standard deviation
      double mean, standardDeviation;
      parameterFile >> mean >> standardDeviation;
      if (! parameterFile.good()) {
        std::cerr << "Could not read Gaussian distribution mean and standard deviation\n";
        parameterFile.close();
        return false;
      }

      if ( options.verbose ) {
        std::cout << "with mean " << mean << " and standard deviation "
                  << standardDeviation << "\n";
      }

      gaussian.SetMean( mean );
      gaussian.SetStandardDeviation( standardDeviation );
      distribution = &gaussian;
    } else {
      std::cerr << "Unknown distribution type '" << distributionType << "'\n";
      parameterFile.close();
      return false;
    }
    parameters.push_back( madai::Parameter( parameterName, *distribution ) );
    discard_comments(parameterFile, '#');
  }

  parameterFile.close();
  // Everything went okay
  return true;
}


bool WriteDirectoriesFormat( const struct CommandLineOptions & options,
                             const std::vector< madai::Parameter > & parameters,
                             const std::vector< madai::Sample > & samples ) {
  // Create the directory structure
  bool directoryCreated = madaisys::SystemTools::MakeDirectory( options.outputDirectory );
  if ( !directoryCreated ) {
    std::cerr << "Could not create directory '" << options.outputDirectory
              << "'\n";
    return false;
  }

  std::string directory( options.outputDirectory );
  std::string experimental_results(
    directory + madai::Paths::SEPARATOR + madai::Paths::EXPERIMENTAL_RESULTS_DIRECTORY );
  std::string model_outputs(
    directory + madai::Paths::SEPARATOR + madai::Paths::MODEL_OUTPUT_DIRECTORY );
  std::string statistical_analysis(
    directory + madai::Paths::SEPARATOR + "statistical_analysis" );

  directoryCreated = directoryCreated &&
    madaisys::SystemTools::MakeDirectory( experimental_results.c_str() );
  directoryCreated = directoryCreated &&
    madaisys::SystemTools::MakeDirectory( model_outputs.c_str() );
  directoryCreated = directoryCreated &&
    madaisys::SystemTools::MakeDirectory( statistical_analysis.c_str() );

  // Now create the run directories
  for ( size_t i = 0; i < samples.size(); ++i ) {
    const madai::Sample & sample = samples[i];

    std::ostringstream buffer;
    buffer << model_outputs << "/run"
           << std::setw( 7 ) << std::setfill( '0' ) << i;
    std::string runDirectory(buffer.str());

    if ( options.verbose ) {
      std::cout << runDirectory << "\n";
    }

    directoryCreated = directoryCreated &&
      madaisys::SystemTools::MakeDirectory( runDirectory.c_str() );

    // Write the parameters to the parameters.dat file
    std::string parametersFile( runDirectory + "/parameters.dat" );
    std::ofstream outfile(parametersFile.c_str());
    if (! outfile) {
      std::cerr << "Could not open file '" << parametersFile << "'\n";
      return false;
    }

    assert( parameters.size() == sample.m_ParameterValues.size() );
    for ( size_t j = 0; j < parameters.size(); ++j ) {
      outfile << parameters[ j ].m_Name << ' '
              << sample.m_ParameterValues[ j ] << '\n';
    }

    outfile.close();
  }

  return true;
}


bool WriteEmulatorFormat( const struct CommandLineOptions & options,
                          const std::vector< madai::Parameter > & parameters,
                          const std::vector< madai::Sample > & samples ) {
  // Create the output directory
  bool directoryCreated = madaisys::SystemTools::MakeDirectory( options.outputDirectory );
  if ( !directoryCreated ) {
    std::cerr << "Could not create directory '" << options.outputDirectory
              << "'\n";
    return false;
  }

  // Open the output file
  std::string outputFile( options.outputDirectory );
  outputFile += "/emulator.dat";
  std::ofstream outfile(outputFile.c_str());
  if (! outfile) {
    std::cerr << "Could not create output file '" << outputFile << "'\n";
    return false;
  }

  // Print some comments
  outfile << "# created by generateTrainingPoints\n";

  // Print VERSION
  outfile << "VERSION 1\n";

  // Print the PARAMETERS
  outfile << "PARAMETERS\n";

  for ( size_t i = 0; i < parameters.size(); ++i ) {
    outfile << parameters[i].m_Name << ' ';
    const madai::Distribution * priorDistribution =
      parameters[i].GetPriorDistribution();
    const madai::UniformDistribution * uniformDistribution =
      dynamic_cast< const madai::UniformDistribution *>( priorDistribution );
    const madai::GaussianDistribution * gaussianDistribution =
      dynamic_cast< const madai::GaussianDistribution *>( priorDistribution );
    if ( uniformDistribution ) {
      outfile << "UNIFORM "
              << uniformDistribution->GetMinimum() << ' '
              << uniformDistribution->GetMaximum() << '\n';
    } else if ( gaussianDistribution ) {
      outfile << "GAUSSIAN "
              << gaussianDistribution->GetMean() << ' '
              << gaussianDistribution->GetStandardDeviation() << '\n';
    } else {
      std::cerr << "Unknown prior type\n";
      return false;
    }
  }

  // Print training points
  outfile << "NUMBER_OF_TRAINING_POINTS " << samples.size() << '\n';

  // Print parameter values at training points
  outfile << "PARAMETER_VALUES\n";

  for ( size_t i = 0; i < samples.size(); ++i ) {
    const madai::Sample & sample = samples[i];

    for ( size_t j = 0; j < sample.m_ParameterValues.size(); ++j ) {
      outfile << sample.m_ParameterValues[j] << ' ';
    }
    outfile << "\n";
  }
  outfile.close();

  return true;
}


int main( int argc, char * argv[] ) {
  struct CommandLineOptions options;
  if ( !ParseCommandLineOptions( argc, argv, options ) ) {
    return EXIT_FAILURE;
  }

  if ( options.verbose ) {
    std::cout << "Options: \n";
    std::cout << "  --verbose: " << options.verbose << "\n";
    std::cout << "  --format: ";
    if ( options.formatType == DIRECTORIES_FORMAT ) std::cout << "directories\n";
    if ( options.formatType == EMULATOR_FORMAT ) std::cout << "emulator\n";
    std::cout << "  --percentile: " << options.partitionSpaceByPercentile << "\n";
    std::cout << "  --stddev: " << options.standardDeviations << "\n";
    std::cout << "  <parameters file>: " << options.parametersFile << "\n";
    std::cout << "  <output directory>: " << options.outputDirectory << "\n";
    std::cout << "  <number of points>: " << options.numberOfTrainingPoints << "\n";
  }

  // Read in parameter priors
  std::vector< madai::Parameter > parameters;
  bool parametersRead = ReadParameters( options, parameters );
  if ( !parametersRead ) {
    std::cerr << "Could not read parameters from prior file '"
              << options.parametersFile << "'" << std::endl;
    return EXIT_FAILURE;
  }

  // Create the Latin hypercube sampling
  madai::LatinHypercubeGenerator sampleGenerator;
  sampleGenerator.SetStandardDeviations( options.standardDeviations );
  sampleGenerator.SetPartitionSpaceByPercentile( options.partitionSpaceByPercentile );

  std::vector< madai::Sample > samples =
    sampleGenerator.Generate( options.numberOfTrainingPoints, parameters );

  if ( options.formatType == DIRECTORIES_FORMAT ) {
    WriteDirectoriesFormat( options, parameters, samples );
  } else if ( options.formatType == EMULATOR_FORMAT ) {
    WriteEmulatorFormat( options, parameters, samples );
  } else {
    std::cerr << "Unknown output format type" << std::endl;
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
